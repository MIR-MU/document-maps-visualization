<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>document-maps documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">document-maps documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>GraphData</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/utils/query.utils.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>An interface, containing the arrays of GraphNodes and GraphLinks passed to the D3 simulation</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#links">links</a>
                                </li>
                                <li>
                                        <a href="#nodes">nodes</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="links"></a>
                                        <span class="name"><b>links</b><a href="#links"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>links:         <code><a href="../interfaces/GraphLink.html" target="_self" >GraphLink[]</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/GraphLink.html" target="_self" >GraphLink[]</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The links of the nodes, holding info about the similarities </p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="nodes"></a>
                                        <span class="name"><b>nodes</b><a href="#nodes"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>nodes:         <code><a href="../interfaces/GraphNode.html" target="_self" >GraphNode[]</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../interfaces/GraphNode.html" target="_self" >GraphNode[]</a></code>

                                        </td>
                                    </tr>





                            <tr>
                                <td class="col-md-4">
                                    <div class="io-description"><p>The nodes to be displayed on the graph </p>
</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {Observable} from &#x27;rxjs&#x27;;
import {pairSeparator} from &#x27;./various.utils&#x27;;

/**
 * The main corpus interface
 */
export interface Corpus {
  /** The map, binding word ids to their actual meaning */
  dictionary: {[key: string]: string};
  /** The object containing individual queries and their top results */
  results: {[key: string]: string[]};
  /** The texts of the document, consisting of an array of word ids */
  texts: {[key: string]: string[]};
  /** The bag of words representation of the document&#x27;s texts */
  texts_bow: {[key: string]: {[key: string]: number}};
  /** The version of the corpus */
  version: string;
  /** The map, containing the cosine similarities between two words */
  word_similarities: {[key: string]: {[key: string]: number}};
}

/**
 * An interface, specifying information about a node in the D3 graph, indirectly inherits from SimulationNodeDatum
 */
export interface GraphNode {
  /** The id of the document, bound to this node */
  id: string;
  /** The group this node belongs to (document, query, ...) */
  group: number;

  index?: number;
  x?: number;
  y?: number;
  vx?: number;
  vy?: number;
  fx?: number | null;
  fy?: number | null;
}

/**
 * An interface, specifying information about a node in the D3 graph, indirectly inherits from SimulationLinkDatum
 */
export interface GraphLink {
  /** The first node&#x27;s id in the relationship */
  source: string;
  /** The second node&#x27;s id in the relationship */
  target: string;
  /** The cosine measure between the two documents */
  value: number;
  index?: number;
}

/**
 * An interface, containing the arrays of GraphNodes and GraphLinks passed to the D3 simulation
 */
export interface GraphData{
  /** The nodes to be displayed on the graph */
  nodes: GraphNode[];
  /** The links of the nodes, holding info about the similarities */
  links: GraphLink[];
}

/**
 * Returns the ID of a given word
 * @param word    The word to retrieve the id of
 * @param corpus  The corpus to perform the query on
 */
export function getWordId(word: string, corpus: Corpus): string {
  // Return the id, that matches the looked for word
  return Object.keys(corpus.dictionary).find(key &#x3D;&gt; corpus.dictionary[key] &#x3D;&#x3D;&#x3D; word);
}

/**
 * Returns the word from dictionary of a given id
 * @param id      The id to retrieve the word of
 * @param corpus  The corpus to perform the query on
 */
export function getWord(id: string, corpus: Corpus): string {
  return corpus.dictionary[id];
}

/**
 * Returns the cosine similarity of two word ids
 * @param id1     The first id to compare
 * @param id2     The second id to compare
 * @param corpus  The corpus to perform the query on
 */
export function getSimilarity(id1: string, id2: string, corpus: Corpus): number {
  // If the ids are the same, then the words are the same
  if (id1 &#x3D;&#x3D;&#x3D; id2) {
    return 1.0;
  }
  // Sort the ids, so that id1 holds the lower id
  if (+id1 &gt; +id2) {
    id2 &#x3D; [id1, id1 &#x3D; id2][0];
  }
  // If the words are not in each others similarities, then they&#x27;re not similar
  if (!(id1 in corpus.word_similarities) || !(id2 in corpus.word_similarities[id1])) {
    return 0.0;
  }
  // Return the found similarity
  return corpus.word_similarities[id1][id2];
}

/**
 * Returns the cosine similarity of two words
 * @param word1   The first word to compare
 * @param word2   The second word to compare
 * @param corpus  The corpus to perform the query on
 */
export function getSimilarityWord(word1: string, word2: string, corpus: Corpus): number{
  // Convert the words to ids
  const w1 &#x3D; getWordId(word1, corpus);
  const w2 &#x3D; getWordId(word2, corpus);
  // Return their similarity
  return getSimilarity(w1, w2, corpus);
}

/**
 * Calculates the inner product of the cosine similarities of two document ids
 * @param id1     The first text id
 * @param id2     The second text id
 * @param corpus  The corpus to perform the query on
 */
export function innerProduct(id1, id2, corpus: Corpus): number{
  const entries1 &#x3D; Object.entries(corpus.texts_bow[id1]);
  const entries2 &#x3D; Object.entries(corpus.texts_bow[id2]);
  let similarity &#x3D; 0.0;
  // Cumulatively add on the similarities of words, and their contributed weights
  for (const [w1ID, w1Weight] of entries1){
    for (const [w2ID, w2Weight] of entries2){
      similarity +&#x3D; getSimilarity(w1ID, w2ID, corpus) * w1Weight * w2Weight;
    }
  }
  return similarity;
}

/**
 * Calculates the inner product of the cosine similarity of one document id
 * @param id      The text id
 * @param corpus  The corpus to perform the query on
 */
export function innerProductSingle(id, corpus: Corpus): number {
  const entries &#x3D; Object.entries(corpus.texts_bow[id]);
  let similarity &#x3D; 0.0;
  // Go over all the pairs of words in the document, skipping, if the pair has been done already
  for (let i &#x3D; 0; i &lt; entries.length; i++){
    for (let j &#x3D; i; j &lt; entries.length; j++){
      const [w1ID, w1Weight] &#x3D; entries[i];
      const [w2ID, w2Weight] &#x3D; entries[j];
      // If we&#x27;re evaluating the same word, multiply it by two, since we need to count it twice
      similarity +&#x3D; getSimilarity(w1ID, w2ID, corpus) * w1Weight * w2Weight * (i &#x3D;&#x3D;&#x3D; j ? 1 : 2);
    }
  }
  return similarity;
}

/**
 * Returns the soft cosine normalization of two word ids
 * @param id1     The first text id
 * @param id2     The second text id
 * @param corpus  The corpus to perform the query on
 */
export function softCosineMeasureNorm(id1, id2, corpus: Corpus): number{
  let norm &#x3D; 1.0;
  // Calculate the inner product for both of the documents, with themselves
  norm *&#x3D; innerProductSingle(id1, corpus) || 1.0;
  norm *&#x3D; innerProductSingle(id2, corpus) || 1.0;
  norm &#x3D; Math.sqrt(norm);
  return norm;
}

/**
 * Returns the soft cosine measure of two texts
 * @param id1     The first text id
 * @param id2     The second text id
 * @param corpus  The corpus to perform the query on
 */
export function getSoftCosineMeasure(id1: string, id2: string, corpus: Corpus): number {
  // Calculate the inner product
  let textSimilarity &#x3D; innerProduct(id1, id2, corpus);
  // Normalize it to range of [0, 1]
  textSimilarity /&#x3D; softCosineMeasureNorm(id1, id2, corpus);
  return textSimilarity;
}

/**
 * Returns the document text
 * @param id      The first text id
 * @param corpus  The corpus to perform the query on
 */
export function getDocumentText(id: string, corpus: Corpus): string{
  // Go over the texts in the document and map the word ids to string words
  const text &#x3D; corpus.texts[id].map(word &#x3D;&gt; getWord(word, corpus));
  // Join up the array and separate the words by spaces
  return text.join(&#x27; &#x27;);
}

/**
 * Returns the normalized word importance pairs
 * @param id1     The first text id
 * @param id2     The second text id
 * @param corpus  The corpus to perform the query on
 */
export function getNormalizedWordImportancePairs(id1: string, id2: string, corpus: Corpus): {[key: string]: number}{
  const bowEntries1 &#x3D; Object.entries(corpus.texts_bow[id1]);
  const bowEntries2 &#x3D; Object.entries(corpus.texts_bow[id2]);

  // Retrieve the most important matched pairs from the documents
  const wordPairs &#x3D; getWordImportancePairs(bowEntries1, bowEntries2, corpus);
  // Get the normalization number
  const norm &#x3D; softCosineMeasureNorm(id1, id2, corpus);
  const normWordPairs: {[key: string]: number} &#x3D; {};
  const wordPairsKeys &#x3D; Object.keys(wordPairs);
  // Go over all the word pairs and normalize them
  for (const id of wordPairsKeys){
    normWordPairs[id] &#x3D; wordPairs[id] / norm;
  }
  return normWordPairs;
}

/**
 * Returns the non-normalized word importance pairs
 * @param bowEntries1 The key-value pairs of the bag of word of the first document
 * @param bowEntries2 The key-value pairs of the bag of word of the second document
 * @param corpus      The corpus to perform the query on
 */
function getWordImportancePairs(bowEntries1: [string, number][], bowEntries2: [string, number][], corpus: Corpus): {[key: string]: number}{
  const wordPairs: {[key: string]: number} &#x3D; {};
  // Iterate over the entries of each bag of words with each other
  for (const [wID1, wWeight1] of bowEntries1) {
    for (const [wID2, wWeight2] of bowEntries2) {
      // Calculate their similarity and importance
      const wordSimilarity &#x3D; getSimilarity(wID1, wID2, corpus);
      const importance &#x3D; wWeight1 * wordSimilarity * wWeight2;
      if (importance &#x3D;&#x3D;&#x3D; 0) {
        // Skip if the words aren&#x27;t similar at all
        continue;
      }
      // Convert to words
      const word1 &#x3D; getWord(wID1, corpus);
      const word2 &#x3D; getWord(wID2, corpus);
      // Pair up the matched words with a default pair separator, defaults to \0
      const wordsKey &#x3D; &#x60;${word1}${pairSeparator}${word2}&#x60;;
      // If the current word pair is not in the output dictionary, create a new entry
      if (!Object.keys(wordPairs).includes(wordsKey)){
        wordPairs[wordsKey] &#x3D; 0.0;
      }
      wordPairs[wordsKey] +&#x3D; importance;
    }
  }
  return wordPairs;
}

/**
 * Filters through the word importance pairs and returns only exact matches
 * @param wordImportancePairs The pairs to filter through
 */
export function getMostImportantExactMatches(wordImportancePairs: any): any{
  const keys &#x3D; Object.keys(wordImportancePairs);
  const exactMatches &#x3D; {};
  // Iterate over the word pairs
  for (const id of keys){
    // Separate them by their pair separator
    const ids &#x3D; id.split(pairSeparator);
    // Only if the words in pairs are the same, add them to the output dictionary
    if (ids[0] &#x3D;&#x3D;&#x3D; ids[1]){
      exactMatches[ids[0]] &#x3D; wordImportancePairs[id];
    }
  }
  return exactMatches;
}

/**
 * Filters through the word importance pairs and returns only soft matches
 * @param wordImportancePairs The pairs to filter through
 */
export function getMostImportantSoftMatches(wordImportancePairs: any): any{
  const keys &#x3D; Object.keys(wordImportancePairs);
  const softMatches &#x3D; {};
  // Iterate over the word pairs
  for (const id of keys){
    // Separate them by their pair separator
    const ids &#x3D; id.split(pairSeparator);
    // Only if the words are not the same, they&#x27;re soft matches, add them to the output dictionary
    if (ids[0] !&#x3D;&#x3D; ids[1]){
      softMatches[id] &#x3D; wordImportancePairs[id];
    }
  }
  return softMatches;
}

/**
 * Cosine distance calculation formula with modifiers
 * @param weight      The cosine similarity of two documents
 * @param multiplier  The linear multiplier of the formula
 * @param clumping    The exponent of the formula
 */
export function calculateCosineDistance(weight: number, multiplier: number &#x3D; 1, clumping: number &#x3D; 1): number{
  return Math.pow(1 - weight, clumping) * multiplier;
}

/**
 * An observable, responsible for creating the GraphNode elements
 * @param corpus  The corpus to create the nodes from
 */
export function createNodes(corpus: Corpus): Observable&lt;{progress: number, data?: GraphNode[]}&gt;{
  // Return a new observable straight away that returns the progress percentage and eventually the data
  return new Observable&lt;{progress: number; data?: GraphNode[]}&gt;(subscriber &#x3D;&gt; {
    const entries &#x3D; Object.entries(corpus.results);
    const nodes: GraphNode[] &#x3D; [];
    // Iterate over the queries in the corpus, storing the index
    let i &#x3D; 0;
    for (const [id, docs] of entries){
      // Send out the current progress percentage, based on the current index and the length of the array
      subscriber.next({progress: (i / entries.length) * 100});
      // Create a new node, with the id and the group 1, indicating that this node is a query
      const node &#x3D; {id, group: 1};
      nodes.push(node);
      // Go over the matched top documents to this query, and create new nodes based on those.
      for (const d of docs) {
        const doc &#x3D; {id: d, group: 2};
        nodes.push(doc);
      }
      i++;
    }
    // When we&#x27;re done, emit the data and that the progress is done
    subscriber.next({progress: 100, data: nodes});
    subscriber.complete();
  });
}

/**
 * An observable, responsible for creating the GraphLinks and calculating the cosine similarity of it
 * @param nodes   The GraphNodes to create the links between
 * @param corpus  The corpus to create the nodes from
 */
export function createLinks(nodes: GraphNode[], corpus: Corpus): Observable&lt;{progress: number, data?: GraphLink[]}&gt;{
  // Return a new observable straight away that returns the progress percentage and eventually the data
  return new Observable&lt;{progress: number; data?: GraphLink[]}&gt;(subscriber &#x3D;&gt; {
    const links: GraphLink[] &#x3D; [];
    // Iterate over all the nodes
    for (let i &#x3D; 0; i &lt; nodes.length; i++) {
      // Output the progress report
      subscriber.next({progress: (i / nodes.length) * 100});
      // Iterate over all the nodes, that we have not made pairs with yet
      for (let j &#x3D; (i + 1); j &lt; nodes.length; j++) {
        const key1 &#x3D; nodes[i].id;
        const key2 &#x3D; nodes[j].id;
        // Calculate the soft cosine measure of the documents
        const scm &#x3D; getSoftCosineMeasure(key1, key2, corpus);
        links.push({source: key1, target: key2, value: scm});
      }
    }
    // When we&#x27;re done, emit the data and that the progress is done
    subscriber.next({progress: 100, data: links});
    subscriber.complete();
  });
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'GraphData.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
